/*
 * Generated by asn1c-1.0.0 (http://lionet.info/asn1c)
 * From ASN.1 module "S1AP-Containers"
 * 	found in "../asn1/S1AP-Containers.asn"
 * 	`asn1c -gen-PER -fcompound-names -S ../skeletons`
 */

#include "ProtocolExtensionField.h"

static int
memb_id_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_5(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_9(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_9(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_9(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_13(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_13(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_13(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_17(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_17(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_17(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_21(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_21(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_21(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_25(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_25(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_25(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_29(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_29(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_29(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_33(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_33(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_33(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_37(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_37(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_37(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_41(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_41(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_41(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_45(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_45(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_45(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_49(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_49(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_49(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_53(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_53(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_53(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_57(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_57(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_57(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_61(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_61(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_61(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_65(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_65(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_65(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_69(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_69(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_69(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_73(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_73(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_73(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_77(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_77(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_77(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_81(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_81(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_81(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_85(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_85(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_85(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_89(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_89(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_89(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_93(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_93(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_93(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_97(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_97(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_97(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_101(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_101(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_101(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_105(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_105(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_105(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_109(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_109(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_109(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_113(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_113(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_113(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_117(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_117(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_117(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_121(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_121(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_121(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_125(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_125(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_125(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_129(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_129(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_129(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_133(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_133(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_133(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_137(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_137(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_137(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_141(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_141(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_141(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_145(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_145(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_145(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_149(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_149(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_149(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_153(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_153(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_153(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_157(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_157(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_157(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_161(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_161(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_161(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_165(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_165(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_165(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_169(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_169(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_169(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_173(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_173(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_173(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_177(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_177(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_177(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_181(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_181(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_181(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_185(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_185(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_185(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_189(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_189(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_189(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_193(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_193(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_193(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_197(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_197(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_197(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_201(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_201(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_201(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_205(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_205(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_205(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_209(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_209(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_209(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_213(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_213(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_213(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_217(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_217(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_217(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_221(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_221(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_221(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_225(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_225(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_225(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_229(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_229(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_229(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_233(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_233(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_233(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_237(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_237(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_237(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_241(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_241(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_241(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_245(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 65535LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_245(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_245(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static asn_per_constraints_t asn_PER_memb_id_constr_2 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_3 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_4 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_6 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_7 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_8 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_10 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_11 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_12 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_14 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_15 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_16 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_18 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_19 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_20 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_22 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_23 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_24 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_26 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_27 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_28 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_30 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_31 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_32 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_34 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_35 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_36 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_38 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_39 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_40 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_42 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_43 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_44 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_46 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_47 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_48 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_50 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_51 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_52 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_54 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_55 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_56 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_58 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_59 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_60 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_62 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_63 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_64 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_66 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_67 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_68 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_70 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_71 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_72 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_74 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_75 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_76 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_78 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_79 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_80 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_82 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_83 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_84 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_86 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_87 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_88 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_90 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_91 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_92 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_94 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_95 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_96 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_98 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_99 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_100 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_102 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_103 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_104 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_106 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_107 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_108 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_110 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_111 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_112 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_114 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_115 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_116 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_118 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_119 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_120 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_122 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_123 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_124 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_126 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_127 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_128 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_130 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_131 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_132 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_134 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_135 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_136 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_138 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_139 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_140 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_142 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_143 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_144 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_146 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_147 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_148 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_150 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_151 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_152 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_154 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_155 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_156 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_158 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_159 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_160 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_162 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_163 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_164 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_166 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_167 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_168 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_170 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_171 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_172 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_174 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_175 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_176 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_178 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_179 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_180 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_182 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_183 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_184 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_186 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_187 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_188 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_190 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_191 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_192 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_194 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_195 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_196 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_198 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_199 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_200 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_202 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_203 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_204 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_206 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_207 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_208 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_210 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_211 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_212 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_214 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_215 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_216 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_218 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_219 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_220 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_222 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_223 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_224 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_226 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_227 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_228 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_230 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_231 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_232 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_234 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_235 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_236 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_238 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_239 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_240 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_242 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_243 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_244 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_246 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0l,  65535l }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_247 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0l,  2l }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_248 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P0_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P0, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_1,
		&asn_PER_memb_id_constr_2,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P0, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_1,
		&asn_PER_memb_criticality_constr_3,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P0, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_1,
		&asn_PER_memb_extensionValue_constr_4,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P0_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P0_tag2el_1[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P0_specs_1 = {
	sizeof(struct ProtocolExtensionField_176P0),
	offsetof(struct ProtocolExtensionField_176P0, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P0_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P0 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P0_tags_1,
	sizeof(asn_DEF_ProtocolExtensionField_176P0_tags_1)
		/sizeof(asn_DEF_ProtocolExtensionField_176P0_tags_1[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P0_tags_1,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P0_tags_1)
		/sizeof(asn_DEF_ProtocolExtensionField_176P0_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P0_1,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P0_specs_1	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P1_5[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P1, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_5,
		&asn_PER_memb_id_constr_6,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P1, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_5,
		&asn_PER_memb_criticality_constr_7,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P1, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_5,
		&asn_PER_memb_extensionValue_constr_8,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P1_tags_5[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P1_tag2el_5[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P1_specs_5 = {
	sizeof(struct ProtocolExtensionField_176P1),
	offsetof(struct ProtocolExtensionField_176P1, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P1_tag2el_5,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P1 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P1_tags_5,
	sizeof(asn_DEF_ProtocolExtensionField_176P1_tags_5)
		/sizeof(asn_DEF_ProtocolExtensionField_176P1_tags_5[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P1_tags_5,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P1_tags_5)
		/sizeof(asn_DEF_ProtocolExtensionField_176P1_tags_5[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P1_5,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P1_specs_5	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P2_9[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P2, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_9,
		&asn_PER_memb_id_constr_10,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P2, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_9,
		&asn_PER_memb_criticality_constr_11,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P2, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_9,
		&asn_PER_memb_extensionValue_constr_12,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P2_tags_9[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P2_tag2el_9[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P2_specs_9 = {
	sizeof(struct ProtocolExtensionField_176P2),
	offsetof(struct ProtocolExtensionField_176P2, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P2_tag2el_9,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P2 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P2_tags_9,
	sizeof(asn_DEF_ProtocolExtensionField_176P2_tags_9)
		/sizeof(asn_DEF_ProtocolExtensionField_176P2_tags_9[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P2_tags_9,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P2_tags_9)
		/sizeof(asn_DEF_ProtocolExtensionField_176P2_tags_9[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P2_9,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P2_specs_9	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P3_13[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P3, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_13,
		&asn_PER_memb_id_constr_14,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P3, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_13,
		&asn_PER_memb_criticality_constr_15,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P3, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_13,
		&asn_PER_memb_extensionValue_constr_16,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P3_tags_13[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P3_tag2el_13[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P3_specs_13 = {
	sizeof(struct ProtocolExtensionField_176P3),
	offsetof(struct ProtocolExtensionField_176P3, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P3_tag2el_13,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P3 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P3_tags_13,
	sizeof(asn_DEF_ProtocolExtensionField_176P3_tags_13)
		/sizeof(asn_DEF_ProtocolExtensionField_176P3_tags_13[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P3_tags_13,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P3_tags_13)
		/sizeof(asn_DEF_ProtocolExtensionField_176P3_tags_13[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P3_13,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P3_specs_13	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P4_17[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P4, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_17,
		&asn_PER_memb_id_constr_18,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P4, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_17,
		&asn_PER_memb_criticality_constr_19,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P4, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_17,
		&asn_PER_memb_extensionValue_constr_20,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P4_tags_17[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P4_tag2el_17[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P4_specs_17 = {
	sizeof(struct ProtocolExtensionField_176P4),
	offsetof(struct ProtocolExtensionField_176P4, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P4_tag2el_17,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P4 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P4_tags_17,
	sizeof(asn_DEF_ProtocolExtensionField_176P4_tags_17)
		/sizeof(asn_DEF_ProtocolExtensionField_176P4_tags_17[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P4_tags_17,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P4_tags_17)
		/sizeof(asn_DEF_ProtocolExtensionField_176P4_tags_17[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P4_17,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P4_specs_17	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P5_21[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P5, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_21,
		&asn_PER_memb_id_constr_22,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P5, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_21,
		&asn_PER_memb_criticality_constr_23,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P5, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_21,
		&asn_PER_memb_extensionValue_constr_24,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P5_tags_21[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P5_tag2el_21[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P5_specs_21 = {
	sizeof(struct ProtocolExtensionField_176P5),
	offsetof(struct ProtocolExtensionField_176P5, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P5_tag2el_21,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P5 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P5_tags_21,
	sizeof(asn_DEF_ProtocolExtensionField_176P5_tags_21)
		/sizeof(asn_DEF_ProtocolExtensionField_176P5_tags_21[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P5_tags_21,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P5_tags_21)
		/sizeof(asn_DEF_ProtocolExtensionField_176P5_tags_21[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P5_21,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P5_specs_21	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P6_25[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P6, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_25,
		&asn_PER_memb_id_constr_26,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P6, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_25,
		&asn_PER_memb_criticality_constr_27,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P6, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_25,
		&asn_PER_memb_extensionValue_constr_28,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P6_tags_25[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P6_tag2el_25[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P6_specs_25 = {
	sizeof(struct ProtocolExtensionField_176P6),
	offsetof(struct ProtocolExtensionField_176P6, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P6_tag2el_25,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P6 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P6_tags_25,
	sizeof(asn_DEF_ProtocolExtensionField_176P6_tags_25)
		/sizeof(asn_DEF_ProtocolExtensionField_176P6_tags_25[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P6_tags_25,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P6_tags_25)
		/sizeof(asn_DEF_ProtocolExtensionField_176P6_tags_25[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P6_25,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P6_specs_25	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P7_29[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P7, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_29,
		&asn_PER_memb_id_constr_30,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P7, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_29,
		&asn_PER_memb_criticality_constr_31,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P7, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_29,
		&asn_PER_memb_extensionValue_constr_32,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P7_tags_29[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P7_tag2el_29[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P7_specs_29 = {
	sizeof(struct ProtocolExtensionField_176P7),
	offsetof(struct ProtocolExtensionField_176P7, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P7_tag2el_29,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P7 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P7_tags_29,
	sizeof(asn_DEF_ProtocolExtensionField_176P7_tags_29)
		/sizeof(asn_DEF_ProtocolExtensionField_176P7_tags_29[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P7_tags_29,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P7_tags_29)
		/sizeof(asn_DEF_ProtocolExtensionField_176P7_tags_29[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P7_29,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P7_specs_29	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P8_33[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P8, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_33,
		&asn_PER_memb_id_constr_34,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P8, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_33,
		&asn_PER_memb_criticality_constr_35,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P8, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_33,
		&asn_PER_memb_extensionValue_constr_36,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P8_tags_33[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P8_tag2el_33[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P8_specs_33 = {
	sizeof(struct ProtocolExtensionField_176P8),
	offsetof(struct ProtocolExtensionField_176P8, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P8_tag2el_33,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P8 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P8_tags_33,
	sizeof(asn_DEF_ProtocolExtensionField_176P8_tags_33)
		/sizeof(asn_DEF_ProtocolExtensionField_176P8_tags_33[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P8_tags_33,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P8_tags_33)
		/sizeof(asn_DEF_ProtocolExtensionField_176P8_tags_33[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P8_33,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P8_specs_33	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P9_37[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P9, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_37,
		&asn_PER_memb_id_constr_38,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P9, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_37,
		&asn_PER_memb_criticality_constr_39,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P9, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_37,
		&asn_PER_memb_extensionValue_constr_40,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P9_tags_37[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P9_tag2el_37[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P9_specs_37 = {
	sizeof(struct ProtocolExtensionField_176P9),
	offsetof(struct ProtocolExtensionField_176P9, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P9_tag2el_37,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P9 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P9_tags_37,
	sizeof(asn_DEF_ProtocolExtensionField_176P9_tags_37)
		/sizeof(asn_DEF_ProtocolExtensionField_176P9_tags_37[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P9_tags_37,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P9_tags_37)
		/sizeof(asn_DEF_ProtocolExtensionField_176P9_tags_37[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P9_37,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P9_specs_37	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P10_41[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P10, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_41,
		&asn_PER_memb_id_constr_42,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P10, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_41,
		&asn_PER_memb_criticality_constr_43,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P10, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_41,
		&asn_PER_memb_extensionValue_constr_44,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P10_tags_41[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P10_tag2el_41[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P10_specs_41 = {
	sizeof(struct ProtocolExtensionField_176P10),
	offsetof(struct ProtocolExtensionField_176P10, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P10_tag2el_41,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P10 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P10_tags_41,
	sizeof(asn_DEF_ProtocolExtensionField_176P10_tags_41)
		/sizeof(asn_DEF_ProtocolExtensionField_176P10_tags_41[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P10_tags_41,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P10_tags_41)
		/sizeof(asn_DEF_ProtocolExtensionField_176P10_tags_41[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P10_41,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P10_specs_41	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P11_45[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P11, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_45,
		&asn_PER_memb_id_constr_46,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P11, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_45,
		&asn_PER_memb_criticality_constr_47,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P11, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_45,
		&asn_PER_memb_extensionValue_constr_48,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P11_tags_45[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P11_tag2el_45[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P11_specs_45 = {
	sizeof(struct ProtocolExtensionField_176P11),
	offsetof(struct ProtocolExtensionField_176P11, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P11_tag2el_45,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P11 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P11_tags_45,
	sizeof(asn_DEF_ProtocolExtensionField_176P11_tags_45)
		/sizeof(asn_DEF_ProtocolExtensionField_176P11_tags_45[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P11_tags_45,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P11_tags_45)
		/sizeof(asn_DEF_ProtocolExtensionField_176P11_tags_45[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P11_45,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P11_specs_45	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P12_49[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P12, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_49,
		&asn_PER_memb_id_constr_50,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P12, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_49,
		&asn_PER_memb_criticality_constr_51,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P12, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_49,
		&asn_PER_memb_extensionValue_constr_52,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P12_tags_49[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P12_tag2el_49[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P12_specs_49 = {
	sizeof(struct ProtocolExtensionField_176P12),
	offsetof(struct ProtocolExtensionField_176P12, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P12_tag2el_49,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P12 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P12_tags_49,
	sizeof(asn_DEF_ProtocolExtensionField_176P12_tags_49)
		/sizeof(asn_DEF_ProtocolExtensionField_176P12_tags_49[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P12_tags_49,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P12_tags_49)
		/sizeof(asn_DEF_ProtocolExtensionField_176P12_tags_49[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P12_49,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P12_specs_49	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P13_53[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P13, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_53,
		&asn_PER_memb_id_constr_54,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P13, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_53,
		&asn_PER_memb_criticality_constr_55,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P13, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_53,
		&asn_PER_memb_extensionValue_constr_56,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P13_tags_53[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P13_tag2el_53[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P13_specs_53 = {
	sizeof(struct ProtocolExtensionField_176P13),
	offsetof(struct ProtocolExtensionField_176P13, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P13_tag2el_53,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P13 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P13_tags_53,
	sizeof(asn_DEF_ProtocolExtensionField_176P13_tags_53)
		/sizeof(asn_DEF_ProtocolExtensionField_176P13_tags_53[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P13_tags_53,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P13_tags_53)
		/sizeof(asn_DEF_ProtocolExtensionField_176P13_tags_53[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P13_53,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P13_specs_53	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P14_57[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P14, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_57,
		&asn_PER_memb_id_constr_58,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P14, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_57,
		&asn_PER_memb_criticality_constr_59,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P14, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_57,
		&asn_PER_memb_extensionValue_constr_60,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P14_tags_57[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P14_tag2el_57[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P14_specs_57 = {
	sizeof(struct ProtocolExtensionField_176P14),
	offsetof(struct ProtocolExtensionField_176P14, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P14_tag2el_57,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P14 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P14_tags_57,
	sizeof(asn_DEF_ProtocolExtensionField_176P14_tags_57)
		/sizeof(asn_DEF_ProtocolExtensionField_176P14_tags_57[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P14_tags_57,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P14_tags_57)
		/sizeof(asn_DEF_ProtocolExtensionField_176P14_tags_57[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P14_57,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P14_specs_57	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P15_61[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P15, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_61,
		&asn_PER_memb_id_constr_62,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P15, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_61,
		&asn_PER_memb_criticality_constr_63,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P15, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_61,
		&asn_PER_memb_extensionValue_constr_64,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P15_tags_61[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P15_tag2el_61[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P15_specs_61 = {
	sizeof(struct ProtocolExtensionField_176P15),
	offsetof(struct ProtocolExtensionField_176P15, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P15_tag2el_61,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P15 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P15_tags_61,
	sizeof(asn_DEF_ProtocolExtensionField_176P15_tags_61)
		/sizeof(asn_DEF_ProtocolExtensionField_176P15_tags_61[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P15_tags_61,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P15_tags_61)
		/sizeof(asn_DEF_ProtocolExtensionField_176P15_tags_61[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P15_61,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P15_specs_61	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P16_65[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P16, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_65,
		&asn_PER_memb_id_constr_66,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P16, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_65,
		&asn_PER_memb_criticality_constr_67,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P16, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_65,
		&asn_PER_memb_extensionValue_constr_68,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P16_tags_65[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P16_tag2el_65[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P16_specs_65 = {
	sizeof(struct ProtocolExtensionField_176P16),
	offsetof(struct ProtocolExtensionField_176P16, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P16_tag2el_65,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P16 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P16_tags_65,
	sizeof(asn_DEF_ProtocolExtensionField_176P16_tags_65)
		/sizeof(asn_DEF_ProtocolExtensionField_176P16_tags_65[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P16_tags_65,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P16_tags_65)
		/sizeof(asn_DEF_ProtocolExtensionField_176P16_tags_65[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P16_65,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P16_specs_65	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P17_69[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P17, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_69,
		&asn_PER_memb_id_constr_70,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P17, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_69,
		&asn_PER_memb_criticality_constr_71,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P17, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_69,
		&asn_PER_memb_extensionValue_constr_72,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P17_tags_69[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P17_tag2el_69[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P17_specs_69 = {
	sizeof(struct ProtocolExtensionField_176P17),
	offsetof(struct ProtocolExtensionField_176P17, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P17_tag2el_69,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P17 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P17_tags_69,
	sizeof(asn_DEF_ProtocolExtensionField_176P17_tags_69)
		/sizeof(asn_DEF_ProtocolExtensionField_176P17_tags_69[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P17_tags_69,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P17_tags_69)
		/sizeof(asn_DEF_ProtocolExtensionField_176P17_tags_69[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P17_69,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P17_specs_69	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P18_73[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P18, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_73,
		&asn_PER_memb_id_constr_74,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P18, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_73,
		&asn_PER_memb_criticality_constr_75,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P18, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_73,
		&asn_PER_memb_extensionValue_constr_76,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P18_tags_73[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P18_tag2el_73[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P18_specs_73 = {
	sizeof(struct ProtocolExtensionField_176P18),
	offsetof(struct ProtocolExtensionField_176P18, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P18_tag2el_73,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P18 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P18_tags_73,
	sizeof(asn_DEF_ProtocolExtensionField_176P18_tags_73)
		/sizeof(asn_DEF_ProtocolExtensionField_176P18_tags_73[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P18_tags_73,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P18_tags_73)
		/sizeof(asn_DEF_ProtocolExtensionField_176P18_tags_73[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P18_73,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P18_specs_73	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P19_77[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P19, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_77,
		&asn_PER_memb_id_constr_78,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P19, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_77,
		&asn_PER_memb_criticality_constr_79,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P19, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_77,
		&asn_PER_memb_extensionValue_constr_80,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P19_tags_77[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P19_tag2el_77[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P19_specs_77 = {
	sizeof(struct ProtocolExtensionField_176P19),
	offsetof(struct ProtocolExtensionField_176P19, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P19_tag2el_77,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P19 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P19_tags_77,
	sizeof(asn_DEF_ProtocolExtensionField_176P19_tags_77)
		/sizeof(asn_DEF_ProtocolExtensionField_176P19_tags_77[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P19_tags_77,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P19_tags_77)
		/sizeof(asn_DEF_ProtocolExtensionField_176P19_tags_77[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P19_77,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P19_specs_77	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P20_81[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P20, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_81,
		&asn_PER_memb_id_constr_82,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P20, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_81,
		&asn_PER_memb_criticality_constr_83,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P20, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_81,
		&asn_PER_memb_extensionValue_constr_84,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P20_tags_81[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P20_tag2el_81[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P20_specs_81 = {
	sizeof(struct ProtocolExtensionField_176P20),
	offsetof(struct ProtocolExtensionField_176P20, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P20_tag2el_81,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P20 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P20_tags_81,
	sizeof(asn_DEF_ProtocolExtensionField_176P20_tags_81)
		/sizeof(asn_DEF_ProtocolExtensionField_176P20_tags_81[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P20_tags_81,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P20_tags_81)
		/sizeof(asn_DEF_ProtocolExtensionField_176P20_tags_81[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P20_81,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P20_specs_81	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P21_85[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P21, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_85,
		&asn_PER_memb_id_constr_86,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P21, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_85,
		&asn_PER_memb_criticality_constr_87,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P21, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_85,
		&asn_PER_memb_extensionValue_constr_88,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P21_tags_85[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P21_tag2el_85[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P21_specs_85 = {
	sizeof(struct ProtocolExtensionField_176P21),
	offsetof(struct ProtocolExtensionField_176P21, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P21_tag2el_85,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P21 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P21_tags_85,
	sizeof(asn_DEF_ProtocolExtensionField_176P21_tags_85)
		/sizeof(asn_DEF_ProtocolExtensionField_176P21_tags_85[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P21_tags_85,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P21_tags_85)
		/sizeof(asn_DEF_ProtocolExtensionField_176P21_tags_85[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P21_85,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P21_specs_85	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P22_89[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P22, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_89,
		&asn_PER_memb_id_constr_90,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P22, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_89,
		&asn_PER_memb_criticality_constr_91,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P22, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_89,
		&asn_PER_memb_extensionValue_constr_92,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P22_tags_89[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P22_tag2el_89[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P22_specs_89 = {
	sizeof(struct ProtocolExtensionField_176P22),
	offsetof(struct ProtocolExtensionField_176P22, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P22_tag2el_89,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P22 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P22_tags_89,
	sizeof(asn_DEF_ProtocolExtensionField_176P22_tags_89)
		/sizeof(asn_DEF_ProtocolExtensionField_176P22_tags_89[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P22_tags_89,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P22_tags_89)
		/sizeof(asn_DEF_ProtocolExtensionField_176P22_tags_89[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P22_89,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P22_specs_89	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P23_93[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P23, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_93,
		&asn_PER_memb_id_constr_94,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P23, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_93,
		&asn_PER_memb_criticality_constr_95,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P23, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_93,
		&asn_PER_memb_extensionValue_constr_96,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P23_tags_93[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P23_tag2el_93[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P23_specs_93 = {
	sizeof(struct ProtocolExtensionField_176P23),
	offsetof(struct ProtocolExtensionField_176P23, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P23_tag2el_93,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P23 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P23_tags_93,
	sizeof(asn_DEF_ProtocolExtensionField_176P23_tags_93)
		/sizeof(asn_DEF_ProtocolExtensionField_176P23_tags_93[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P23_tags_93,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P23_tags_93)
		/sizeof(asn_DEF_ProtocolExtensionField_176P23_tags_93[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P23_93,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P23_specs_93	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P24_97[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P24, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_97,
		&asn_PER_memb_id_constr_98,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P24, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_97,
		&asn_PER_memb_criticality_constr_99,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P24, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_97,
		&asn_PER_memb_extensionValue_constr_100,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P24_tags_97[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P24_tag2el_97[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P24_specs_97 = {
	sizeof(struct ProtocolExtensionField_176P24),
	offsetof(struct ProtocolExtensionField_176P24, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P24_tag2el_97,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P24 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P24_tags_97,
	sizeof(asn_DEF_ProtocolExtensionField_176P24_tags_97)
		/sizeof(asn_DEF_ProtocolExtensionField_176P24_tags_97[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P24_tags_97,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P24_tags_97)
		/sizeof(asn_DEF_ProtocolExtensionField_176P24_tags_97[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P24_97,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P24_specs_97	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P25_101[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P25, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_101,
		&asn_PER_memb_id_constr_102,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P25, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_101,
		&asn_PER_memb_criticality_constr_103,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P25, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_101,
		&asn_PER_memb_extensionValue_constr_104,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P25_tags_101[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P25_tag2el_101[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P25_specs_101 = {
	sizeof(struct ProtocolExtensionField_176P25),
	offsetof(struct ProtocolExtensionField_176P25, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P25_tag2el_101,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P25 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P25_tags_101,
	sizeof(asn_DEF_ProtocolExtensionField_176P25_tags_101)
		/sizeof(asn_DEF_ProtocolExtensionField_176P25_tags_101[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P25_tags_101,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P25_tags_101)
		/sizeof(asn_DEF_ProtocolExtensionField_176P25_tags_101[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P25_101,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P25_specs_101	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P26_105[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P26, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_105,
		&asn_PER_memb_id_constr_106,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P26, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_105,
		&asn_PER_memb_criticality_constr_107,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P26, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_105,
		&asn_PER_memb_extensionValue_constr_108,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P26_tags_105[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P26_tag2el_105[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P26_specs_105 = {
	sizeof(struct ProtocolExtensionField_176P26),
	offsetof(struct ProtocolExtensionField_176P26, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P26_tag2el_105,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P26 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P26_tags_105,
	sizeof(asn_DEF_ProtocolExtensionField_176P26_tags_105)
		/sizeof(asn_DEF_ProtocolExtensionField_176P26_tags_105[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P26_tags_105,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P26_tags_105)
		/sizeof(asn_DEF_ProtocolExtensionField_176P26_tags_105[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P26_105,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P26_specs_105	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P27_109[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P27, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_109,
		&asn_PER_memb_id_constr_110,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P27, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_109,
		&asn_PER_memb_criticality_constr_111,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P27, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_109,
		&asn_PER_memb_extensionValue_constr_112,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P27_tags_109[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P27_tag2el_109[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P27_specs_109 = {
	sizeof(struct ProtocolExtensionField_176P27),
	offsetof(struct ProtocolExtensionField_176P27, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P27_tag2el_109,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P27 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P27_tags_109,
	sizeof(asn_DEF_ProtocolExtensionField_176P27_tags_109)
		/sizeof(asn_DEF_ProtocolExtensionField_176P27_tags_109[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P27_tags_109,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P27_tags_109)
		/sizeof(asn_DEF_ProtocolExtensionField_176P27_tags_109[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P27_109,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P27_specs_109	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P28_113[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P28, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_113,
		&asn_PER_memb_id_constr_114,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P28, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_113,
		&asn_PER_memb_criticality_constr_115,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P28, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_113,
		&asn_PER_memb_extensionValue_constr_116,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P28_tags_113[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P28_tag2el_113[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P28_specs_113 = {
	sizeof(struct ProtocolExtensionField_176P28),
	offsetof(struct ProtocolExtensionField_176P28, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P28_tag2el_113,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P28 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P28_tags_113,
	sizeof(asn_DEF_ProtocolExtensionField_176P28_tags_113)
		/sizeof(asn_DEF_ProtocolExtensionField_176P28_tags_113[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P28_tags_113,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P28_tags_113)
		/sizeof(asn_DEF_ProtocolExtensionField_176P28_tags_113[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P28_113,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P28_specs_113	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P29_117[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P29, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_117,
		&asn_PER_memb_id_constr_118,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P29, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_117,
		&asn_PER_memb_criticality_constr_119,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P29, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_117,
		&asn_PER_memb_extensionValue_constr_120,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P29_tags_117[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P29_tag2el_117[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P29_specs_117 = {
	sizeof(struct ProtocolExtensionField_176P29),
	offsetof(struct ProtocolExtensionField_176P29, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P29_tag2el_117,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P29 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P29_tags_117,
	sizeof(asn_DEF_ProtocolExtensionField_176P29_tags_117)
		/sizeof(asn_DEF_ProtocolExtensionField_176P29_tags_117[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P29_tags_117,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P29_tags_117)
		/sizeof(asn_DEF_ProtocolExtensionField_176P29_tags_117[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P29_117,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P29_specs_117	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P30_121[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P30, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_121,
		&asn_PER_memb_id_constr_122,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P30, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_121,
		&asn_PER_memb_criticality_constr_123,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P30, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_121,
		&asn_PER_memb_extensionValue_constr_124,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P30_tags_121[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P30_tag2el_121[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P30_specs_121 = {
	sizeof(struct ProtocolExtensionField_176P30),
	offsetof(struct ProtocolExtensionField_176P30, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P30_tag2el_121,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P30 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P30_tags_121,
	sizeof(asn_DEF_ProtocolExtensionField_176P30_tags_121)
		/sizeof(asn_DEF_ProtocolExtensionField_176P30_tags_121[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P30_tags_121,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P30_tags_121)
		/sizeof(asn_DEF_ProtocolExtensionField_176P30_tags_121[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P30_121,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P30_specs_121	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P31_125[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P31, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_125,
		&asn_PER_memb_id_constr_126,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P31, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_125,
		&asn_PER_memb_criticality_constr_127,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P31, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_125,
		&asn_PER_memb_extensionValue_constr_128,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P31_tags_125[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P31_tag2el_125[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P31_specs_125 = {
	sizeof(struct ProtocolExtensionField_176P31),
	offsetof(struct ProtocolExtensionField_176P31, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P31_tag2el_125,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P31 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P31_tags_125,
	sizeof(asn_DEF_ProtocolExtensionField_176P31_tags_125)
		/sizeof(asn_DEF_ProtocolExtensionField_176P31_tags_125[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P31_tags_125,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P31_tags_125)
		/sizeof(asn_DEF_ProtocolExtensionField_176P31_tags_125[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P31_125,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P31_specs_125	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P32_129[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P32, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_129,
		&asn_PER_memb_id_constr_130,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P32, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_129,
		&asn_PER_memb_criticality_constr_131,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P32, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_129,
		&asn_PER_memb_extensionValue_constr_132,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P32_tags_129[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P32_tag2el_129[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P32_specs_129 = {
	sizeof(struct ProtocolExtensionField_176P32),
	offsetof(struct ProtocolExtensionField_176P32, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P32_tag2el_129,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P32 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P32_tags_129,
	sizeof(asn_DEF_ProtocolExtensionField_176P32_tags_129)
		/sizeof(asn_DEF_ProtocolExtensionField_176P32_tags_129[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P32_tags_129,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P32_tags_129)
		/sizeof(asn_DEF_ProtocolExtensionField_176P32_tags_129[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P32_129,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P32_specs_129	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P33_133[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P33, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_133,
		&asn_PER_memb_id_constr_134,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P33, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_133,
		&asn_PER_memb_criticality_constr_135,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P33, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_133,
		&asn_PER_memb_extensionValue_constr_136,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P33_tags_133[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P33_tag2el_133[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P33_specs_133 = {
	sizeof(struct ProtocolExtensionField_176P33),
	offsetof(struct ProtocolExtensionField_176P33, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P33_tag2el_133,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P33 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P33_tags_133,
	sizeof(asn_DEF_ProtocolExtensionField_176P33_tags_133)
		/sizeof(asn_DEF_ProtocolExtensionField_176P33_tags_133[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P33_tags_133,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P33_tags_133)
		/sizeof(asn_DEF_ProtocolExtensionField_176P33_tags_133[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P33_133,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P33_specs_133	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P34_137[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P34, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_137,
		&asn_PER_memb_id_constr_138,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P34, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_137,
		&asn_PER_memb_criticality_constr_139,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P34, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_137,
		&asn_PER_memb_extensionValue_constr_140,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P34_tags_137[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P34_tag2el_137[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P34_specs_137 = {
	sizeof(struct ProtocolExtensionField_176P34),
	offsetof(struct ProtocolExtensionField_176P34, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P34_tag2el_137,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P34 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P34_tags_137,
	sizeof(asn_DEF_ProtocolExtensionField_176P34_tags_137)
		/sizeof(asn_DEF_ProtocolExtensionField_176P34_tags_137[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P34_tags_137,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P34_tags_137)
		/sizeof(asn_DEF_ProtocolExtensionField_176P34_tags_137[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P34_137,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P34_specs_137	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P35_141[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P35, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_141,
		&asn_PER_memb_id_constr_142,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P35, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_141,
		&asn_PER_memb_criticality_constr_143,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P35, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_141,
		&asn_PER_memb_extensionValue_constr_144,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P35_tags_141[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P35_tag2el_141[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P35_specs_141 = {
	sizeof(struct ProtocolExtensionField_176P35),
	offsetof(struct ProtocolExtensionField_176P35, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P35_tag2el_141,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P35 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P35_tags_141,
	sizeof(asn_DEF_ProtocolExtensionField_176P35_tags_141)
		/sizeof(asn_DEF_ProtocolExtensionField_176P35_tags_141[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P35_tags_141,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P35_tags_141)
		/sizeof(asn_DEF_ProtocolExtensionField_176P35_tags_141[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P35_141,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P35_specs_141	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P36_145[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P36, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_145,
		&asn_PER_memb_id_constr_146,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P36, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_145,
		&asn_PER_memb_criticality_constr_147,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P36, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_145,
		&asn_PER_memb_extensionValue_constr_148,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P36_tags_145[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P36_tag2el_145[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P36_specs_145 = {
	sizeof(struct ProtocolExtensionField_176P36),
	offsetof(struct ProtocolExtensionField_176P36, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P36_tag2el_145,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P36 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P36_tags_145,
	sizeof(asn_DEF_ProtocolExtensionField_176P36_tags_145)
		/sizeof(asn_DEF_ProtocolExtensionField_176P36_tags_145[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P36_tags_145,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P36_tags_145)
		/sizeof(asn_DEF_ProtocolExtensionField_176P36_tags_145[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P36_145,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P36_specs_145	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P37_149[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P37, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_149,
		&asn_PER_memb_id_constr_150,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P37, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_149,
		&asn_PER_memb_criticality_constr_151,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P37, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_149,
		&asn_PER_memb_extensionValue_constr_152,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P37_tags_149[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P37_tag2el_149[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P37_specs_149 = {
	sizeof(struct ProtocolExtensionField_176P37),
	offsetof(struct ProtocolExtensionField_176P37, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P37_tag2el_149,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P37 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P37_tags_149,
	sizeof(asn_DEF_ProtocolExtensionField_176P37_tags_149)
		/sizeof(asn_DEF_ProtocolExtensionField_176P37_tags_149[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P37_tags_149,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P37_tags_149)
		/sizeof(asn_DEF_ProtocolExtensionField_176P37_tags_149[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P37_149,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P37_specs_149	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P38_153[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P38, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_153,
		&asn_PER_memb_id_constr_154,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P38, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_153,
		&asn_PER_memb_criticality_constr_155,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P38, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_153,
		&asn_PER_memb_extensionValue_constr_156,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P38_tags_153[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P38_tag2el_153[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P38_specs_153 = {
	sizeof(struct ProtocolExtensionField_176P38),
	offsetof(struct ProtocolExtensionField_176P38, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P38_tag2el_153,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P38 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P38_tags_153,
	sizeof(asn_DEF_ProtocolExtensionField_176P38_tags_153)
		/sizeof(asn_DEF_ProtocolExtensionField_176P38_tags_153[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P38_tags_153,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P38_tags_153)
		/sizeof(asn_DEF_ProtocolExtensionField_176P38_tags_153[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P38_153,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P38_specs_153	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P39_157[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P39, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_157,
		&asn_PER_memb_id_constr_158,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P39, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_157,
		&asn_PER_memb_criticality_constr_159,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P39, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_157,
		&asn_PER_memb_extensionValue_constr_160,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P39_tags_157[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P39_tag2el_157[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P39_specs_157 = {
	sizeof(struct ProtocolExtensionField_176P39),
	offsetof(struct ProtocolExtensionField_176P39, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P39_tag2el_157,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P39 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P39_tags_157,
	sizeof(asn_DEF_ProtocolExtensionField_176P39_tags_157)
		/sizeof(asn_DEF_ProtocolExtensionField_176P39_tags_157[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P39_tags_157,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P39_tags_157)
		/sizeof(asn_DEF_ProtocolExtensionField_176P39_tags_157[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P39_157,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P39_specs_157	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P40_161[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P40, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_161,
		&asn_PER_memb_id_constr_162,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P40, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_161,
		&asn_PER_memb_criticality_constr_163,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P40, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_161,
		&asn_PER_memb_extensionValue_constr_164,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P40_tags_161[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P40_tag2el_161[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P40_specs_161 = {
	sizeof(struct ProtocolExtensionField_176P40),
	offsetof(struct ProtocolExtensionField_176P40, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P40_tag2el_161,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P40 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P40_tags_161,
	sizeof(asn_DEF_ProtocolExtensionField_176P40_tags_161)
		/sizeof(asn_DEF_ProtocolExtensionField_176P40_tags_161[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P40_tags_161,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P40_tags_161)
		/sizeof(asn_DEF_ProtocolExtensionField_176P40_tags_161[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P40_161,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P40_specs_161	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P41_165[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P41, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_165,
		&asn_PER_memb_id_constr_166,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P41, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_165,
		&asn_PER_memb_criticality_constr_167,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P41, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_165,
		&asn_PER_memb_extensionValue_constr_168,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P41_tags_165[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P41_tag2el_165[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P41_specs_165 = {
	sizeof(struct ProtocolExtensionField_176P41),
	offsetof(struct ProtocolExtensionField_176P41, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P41_tag2el_165,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P41 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P41_tags_165,
	sizeof(asn_DEF_ProtocolExtensionField_176P41_tags_165)
		/sizeof(asn_DEF_ProtocolExtensionField_176P41_tags_165[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P41_tags_165,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P41_tags_165)
		/sizeof(asn_DEF_ProtocolExtensionField_176P41_tags_165[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P41_165,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P41_specs_165	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P42_169[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P42, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_169,
		&asn_PER_memb_id_constr_170,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P42, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_169,
		&asn_PER_memb_criticality_constr_171,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P42, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_169,
		&asn_PER_memb_extensionValue_constr_172,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P42_tags_169[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P42_tag2el_169[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P42_specs_169 = {
	sizeof(struct ProtocolExtensionField_176P42),
	offsetof(struct ProtocolExtensionField_176P42, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P42_tag2el_169,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P42 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P42_tags_169,
	sizeof(asn_DEF_ProtocolExtensionField_176P42_tags_169)
		/sizeof(asn_DEF_ProtocolExtensionField_176P42_tags_169[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P42_tags_169,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P42_tags_169)
		/sizeof(asn_DEF_ProtocolExtensionField_176P42_tags_169[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P42_169,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P42_specs_169	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P43_173[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P43, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_173,
		&asn_PER_memb_id_constr_174,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P43, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_173,
		&asn_PER_memb_criticality_constr_175,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P43, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_173,
		&asn_PER_memb_extensionValue_constr_176,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P43_tags_173[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P43_tag2el_173[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P43_specs_173 = {
	sizeof(struct ProtocolExtensionField_176P43),
	offsetof(struct ProtocolExtensionField_176P43, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P43_tag2el_173,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P43 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P43_tags_173,
	sizeof(asn_DEF_ProtocolExtensionField_176P43_tags_173)
		/sizeof(asn_DEF_ProtocolExtensionField_176P43_tags_173[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P43_tags_173,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P43_tags_173)
		/sizeof(asn_DEF_ProtocolExtensionField_176P43_tags_173[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P43_173,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P43_specs_173	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P44_177[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P44, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_177,
		&asn_PER_memb_id_constr_178,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P44, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_177,
		&asn_PER_memb_criticality_constr_179,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P44, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_177,
		&asn_PER_memb_extensionValue_constr_180,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P44_tags_177[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P44_tag2el_177[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P44_specs_177 = {
	sizeof(struct ProtocolExtensionField_176P44),
	offsetof(struct ProtocolExtensionField_176P44, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P44_tag2el_177,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P44 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P44_tags_177,
	sizeof(asn_DEF_ProtocolExtensionField_176P44_tags_177)
		/sizeof(asn_DEF_ProtocolExtensionField_176P44_tags_177[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P44_tags_177,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P44_tags_177)
		/sizeof(asn_DEF_ProtocolExtensionField_176P44_tags_177[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P44_177,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P44_specs_177	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P45_181[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P45, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_181,
		&asn_PER_memb_id_constr_182,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P45, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_181,
		&asn_PER_memb_criticality_constr_183,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P45, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_181,
		&asn_PER_memb_extensionValue_constr_184,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P45_tags_181[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P45_tag2el_181[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P45_specs_181 = {
	sizeof(struct ProtocolExtensionField_176P45),
	offsetof(struct ProtocolExtensionField_176P45, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P45_tag2el_181,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P45 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P45_tags_181,
	sizeof(asn_DEF_ProtocolExtensionField_176P45_tags_181)
		/sizeof(asn_DEF_ProtocolExtensionField_176P45_tags_181[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P45_tags_181,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P45_tags_181)
		/sizeof(asn_DEF_ProtocolExtensionField_176P45_tags_181[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P45_181,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P45_specs_181	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P46_185[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P46, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_185,
		&asn_PER_memb_id_constr_186,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P46, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_185,
		&asn_PER_memb_criticality_constr_187,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P46, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_185,
		&asn_PER_memb_extensionValue_constr_188,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P46_tags_185[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P46_tag2el_185[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P46_specs_185 = {
	sizeof(struct ProtocolExtensionField_176P46),
	offsetof(struct ProtocolExtensionField_176P46, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P46_tag2el_185,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P46 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P46_tags_185,
	sizeof(asn_DEF_ProtocolExtensionField_176P46_tags_185)
		/sizeof(asn_DEF_ProtocolExtensionField_176P46_tags_185[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P46_tags_185,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P46_tags_185)
		/sizeof(asn_DEF_ProtocolExtensionField_176P46_tags_185[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P46_185,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P46_specs_185	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P47_189[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P47, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_189,
		&asn_PER_memb_id_constr_190,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P47, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_189,
		&asn_PER_memb_criticality_constr_191,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P47, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_189,
		&asn_PER_memb_extensionValue_constr_192,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P47_tags_189[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P47_tag2el_189[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P47_specs_189 = {
	sizeof(struct ProtocolExtensionField_176P47),
	offsetof(struct ProtocolExtensionField_176P47, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P47_tag2el_189,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P47 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P47_tags_189,
	sizeof(asn_DEF_ProtocolExtensionField_176P47_tags_189)
		/sizeof(asn_DEF_ProtocolExtensionField_176P47_tags_189[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P47_tags_189,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P47_tags_189)
		/sizeof(asn_DEF_ProtocolExtensionField_176P47_tags_189[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P47_189,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P47_specs_189	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P48_193[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P48, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_193,
		&asn_PER_memb_id_constr_194,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P48, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_193,
		&asn_PER_memb_criticality_constr_195,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P48, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_193,
		&asn_PER_memb_extensionValue_constr_196,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P48_tags_193[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P48_tag2el_193[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P48_specs_193 = {
	sizeof(struct ProtocolExtensionField_176P48),
	offsetof(struct ProtocolExtensionField_176P48, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P48_tag2el_193,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P48 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P48_tags_193,
	sizeof(asn_DEF_ProtocolExtensionField_176P48_tags_193)
		/sizeof(asn_DEF_ProtocolExtensionField_176P48_tags_193[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P48_tags_193,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P48_tags_193)
		/sizeof(asn_DEF_ProtocolExtensionField_176P48_tags_193[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P48_193,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P48_specs_193	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P49_197[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P49, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_197,
		&asn_PER_memb_id_constr_198,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P49, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_197,
		&asn_PER_memb_criticality_constr_199,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P49, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_197,
		&asn_PER_memb_extensionValue_constr_200,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P49_tags_197[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P49_tag2el_197[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P49_specs_197 = {
	sizeof(struct ProtocolExtensionField_176P49),
	offsetof(struct ProtocolExtensionField_176P49, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P49_tag2el_197,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P49 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P49_tags_197,
	sizeof(asn_DEF_ProtocolExtensionField_176P49_tags_197)
		/sizeof(asn_DEF_ProtocolExtensionField_176P49_tags_197[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P49_tags_197,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P49_tags_197)
		/sizeof(asn_DEF_ProtocolExtensionField_176P49_tags_197[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P49_197,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P49_specs_197	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P50_201[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P50, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_201,
		&asn_PER_memb_id_constr_202,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P50, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_201,
		&asn_PER_memb_criticality_constr_203,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P50, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_201,
		&asn_PER_memb_extensionValue_constr_204,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P50_tags_201[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P50_tag2el_201[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P50_specs_201 = {
	sizeof(struct ProtocolExtensionField_176P50),
	offsetof(struct ProtocolExtensionField_176P50, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P50_tag2el_201,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P50 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P50_tags_201,
	sizeof(asn_DEF_ProtocolExtensionField_176P50_tags_201)
		/sizeof(asn_DEF_ProtocolExtensionField_176P50_tags_201[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P50_tags_201,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P50_tags_201)
		/sizeof(asn_DEF_ProtocolExtensionField_176P50_tags_201[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P50_201,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P50_specs_201	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P51_205[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P51, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_205,
		&asn_PER_memb_id_constr_206,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P51, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_205,
		&asn_PER_memb_criticality_constr_207,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P51, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_205,
		&asn_PER_memb_extensionValue_constr_208,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P51_tags_205[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P51_tag2el_205[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P51_specs_205 = {
	sizeof(struct ProtocolExtensionField_176P51),
	offsetof(struct ProtocolExtensionField_176P51, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P51_tag2el_205,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P51 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P51_tags_205,
	sizeof(asn_DEF_ProtocolExtensionField_176P51_tags_205)
		/sizeof(asn_DEF_ProtocolExtensionField_176P51_tags_205[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P51_tags_205,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P51_tags_205)
		/sizeof(asn_DEF_ProtocolExtensionField_176P51_tags_205[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P51_205,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P51_specs_205	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P52_209[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P52, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_209,
		&asn_PER_memb_id_constr_210,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P52, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_209,
		&asn_PER_memb_criticality_constr_211,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P52, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_209,
		&asn_PER_memb_extensionValue_constr_212,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P52_tags_209[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P52_tag2el_209[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P52_specs_209 = {
	sizeof(struct ProtocolExtensionField_176P52),
	offsetof(struct ProtocolExtensionField_176P52, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P52_tag2el_209,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P52 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P52_tags_209,
	sizeof(asn_DEF_ProtocolExtensionField_176P52_tags_209)
		/sizeof(asn_DEF_ProtocolExtensionField_176P52_tags_209[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P52_tags_209,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P52_tags_209)
		/sizeof(asn_DEF_ProtocolExtensionField_176P52_tags_209[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P52_209,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P52_specs_209	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P53_213[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P53, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_213,
		&asn_PER_memb_id_constr_214,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P53, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_213,
		&asn_PER_memb_criticality_constr_215,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P53, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_213,
		&asn_PER_memb_extensionValue_constr_216,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P53_tags_213[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P53_tag2el_213[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P53_specs_213 = {
	sizeof(struct ProtocolExtensionField_176P53),
	offsetof(struct ProtocolExtensionField_176P53, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P53_tag2el_213,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P53 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P53_tags_213,
	sizeof(asn_DEF_ProtocolExtensionField_176P53_tags_213)
		/sizeof(asn_DEF_ProtocolExtensionField_176P53_tags_213[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P53_tags_213,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P53_tags_213)
		/sizeof(asn_DEF_ProtocolExtensionField_176P53_tags_213[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P53_213,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P53_specs_213	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P54_217[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P54, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_217,
		&asn_PER_memb_id_constr_218,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P54, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_217,
		&asn_PER_memb_criticality_constr_219,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P54, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_217,
		&asn_PER_memb_extensionValue_constr_220,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P54_tags_217[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P54_tag2el_217[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P54_specs_217 = {
	sizeof(struct ProtocolExtensionField_176P54),
	offsetof(struct ProtocolExtensionField_176P54, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P54_tag2el_217,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P54 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P54_tags_217,
	sizeof(asn_DEF_ProtocolExtensionField_176P54_tags_217)
		/sizeof(asn_DEF_ProtocolExtensionField_176P54_tags_217[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P54_tags_217,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P54_tags_217)
		/sizeof(asn_DEF_ProtocolExtensionField_176P54_tags_217[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P54_217,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P54_specs_217	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P55_221[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P55, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_221,
		&asn_PER_memb_id_constr_222,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P55, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_221,
		&asn_PER_memb_criticality_constr_223,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P55, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_221,
		&asn_PER_memb_extensionValue_constr_224,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P55_tags_221[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P55_tag2el_221[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P55_specs_221 = {
	sizeof(struct ProtocolExtensionField_176P55),
	offsetof(struct ProtocolExtensionField_176P55, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P55_tag2el_221,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P55 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P55_tags_221,
	sizeof(asn_DEF_ProtocolExtensionField_176P55_tags_221)
		/sizeof(asn_DEF_ProtocolExtensionField_176P55_tags_221[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P55_tags_221,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P55_tags_221)
		/sizeof(asn_DEF_ProtocolExtensionField_176P55_tags_221[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P55_221,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P55_specs_221	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P56_225[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P56, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_225,
		&asn_PER_memb_id_constr_226,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P56, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_225,
		&asn_PER_memb_criticality_constr_227,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P56, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_225,
		&asn_PER_memb_extensionValue_constr_228,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P56_tags_225[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P56_tag2el_225[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P56_specs_225 = {
	sizeof(struct ProtocolExtensionField_176P56),
	offsetof(struct ProtocolExtensionField_176P56, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P56_tag2el_225,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P56 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P56_tags_225,
	sizeof(asn_DEF_ProtocolExtensionField_176P56_tags_225)
		/sizeof(asn_DEF_ProtocolExtensionField_176P56_tags_225[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P56_tags_225,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P56_tags_225)
		/sizeof(asn_DEF_ProtocolExtensionField_176P56_tags_225[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P56_225,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P56_specs_225	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P57_229[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P57, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_229,
		&asn_PER_memb_id_constr_230,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P57, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_229,
		&asn_PER_memb_criticality_constr_231,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P57, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_229,
		&asn_PER_memb_extensionValue_constr_232,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P57_tags_229[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P57_tag2el_229[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P57_specs_229 = {
	sizeof(struct ProtocolExtensionField_176P57),
	offsetof(struct ProtocolExtensionField_176P57, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P57_tag2el_229,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P57 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P57_tags_229,
	sizeof(asn_DEF_ProtocolExtensionField_176P57_tags_229)
		/sizeof(asn_DEF_ProtocolExtensionField_176P57_tags_229[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P57_tags_229,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P57_tags_229)
		/sizeof(asn_DEF_ProtocolExtensionField_176P57_tags_229[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P57_229,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P57_specs_229	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P58_233[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P58, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_233,
		&asn_PER_memb_id_constr_234,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P58, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_233,
		&asn_PER_memb_criticality_constr_235,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P58, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_233,
		&asn_PER_memb_extensionValue_constr_236,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P58_tags_233[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P58_tag2el_233[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P58_specs_233 = {
	sizeof(struct ProtocolExtensionField_176P58),
	offsetof(struct ProtocolExtensionField_176P58, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P58_tag2el_233,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P58 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P58_tags_233,
	sizeof(asn_DEF_ProtocolExtensionField_176P58_tags_233)
		/sizeof(asn_DEF_ProtocolExtensionField_176P58_tags_233[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P58_tags_233,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P58_tags_233)
		/sizeof(asn_DEF_ProtocolExtensionField_176P58_tags_233[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P58_233,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P58_specs_233	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P59_237[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P59, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_237,
		&asn_PER_memb_id_constr_238,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P59, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_237,
		&asn_PER_memb_criticality_constr_239,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P59, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_237,
		&asn_PER_memb_extensionValue_constr_240,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P59_tags_237[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P59_tag2el_237[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P59_specs_237 = {
	sizeof(struct ProtocolExtensionField_176P59),
	offsetof(struct ProtocolExtensionField_176P59, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P59_tag2el_237,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P59 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P59_tags_237,
	sizeof(asn_DEF_ProtocolExtensionField_176P59_tags_237)
		/sizeof(asn_DEF_ProtocolExtensionField_176P59_tags_237[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P59_tags_237,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P59_tags_237)
		/sizeof(asn_DEF_ProtocolExtensionField_176P59_tags_237[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P59_237,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P59_specs_237	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P60_241[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P60, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_241,
		&asn_PER_memb_id_constr_242,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P60, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_241,
		&asn_PER_memb_criticality_constr_243,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P60, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_241,
		&asn_PER_memb_extensionValue_constr_244,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P60_tags_241[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P60_tag2el_241[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P60_specs_241 = {
	sizeof(struct ProtocolExtensionField_176P60),
	offsetof(struct ProtocolExtensionField_176P60, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P60_tag2el_241,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P60 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P60_tags_241,
	sizeof(asn_DEF_ProtocolExtensionField_176P60_tags_241)
		/sizeof(asn_DEF_ProtocolExtensionField_176P60_tags_241[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P60_tags_241,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P60_tags_241)
		/sizeof(asn_DEF_ProtocolExtensionField_176P60_tags_241[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P60_241,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P60_specs_241	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ProtocolExtensionField_176P61_245[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P61, id),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_ProtocolExtensionID,
		memb_id_constraint_245,
		&asn_PER_memb_id_constr_246,
		0,
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P61, criticality),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_Criticality,
		memb_criticality_constraint_245,
		&asn_PER_memb_criticality_constr_247,
		0,
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ProtocolExtensionField_176P61, extensionValue),
		-1 /* Ambiguous tag (ANY?) */,
		0,
		&asn_DEF_ANY,
		memb_extensionValue_constraint_245,
		&asn_PER_memb_extensionValue_constr_248,
		0,
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ProtocolExtensionField_176P61_tags_245[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ProtocolExtensionField_176P61_tag2el_245[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0 } /* criticality */
};
asn_SEQUENCE_specifics_t asn_SPC_ProtocolExtensionField_176P61_specs_245 = {
	sizeof(struct ProtocolExtensionField_176P61),
	offsetof(struct ProtocolExtensionField_176P61, _asn_ctx),
	asn_MAP_ProtocolExtensionField_176P61_tag2el_245,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_ProtocolExtensionField_176P61 = {
	"ProtocolExtensionField",
	"ProtocolExtensionField",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_ProtocolExtensionField_176P61_tags_245,
	sizeof(asn_DEF_ProtocolExtensionField_176P61_tags_245)
		/sizeof(asn_DEF_ProtocolExtensionField_176P61_tags_245[0]), /* 1 */
	asn_DEF_ProtocolExtensionField_176P61_tags_245,	/* Same as above */
	sizeof(asn_DEF_ProtocolExtensionField_176P61_tags_245)
		/sizeof(asn_DEF_ProtocolExtensionField_176P61_tags_245[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ProtocolExtensionField_176P61_245,
	3,	/* Elements count */
	&asn_SPC_ProtocolExtensionField_176P61_specs_245	/* Additional specs */
};

